<!DOCTYPE html>
<html lang="en">
  <!-- Head tag -->
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Title -->
  
  <title>Swift炫酷动效StarWars.iOS剖析 - I&#39;m Fnoz</title>

  <!--Favicon-->
  <link rel="icon" href="favicon/favicon.ico">

  <!--Description-->
  
      <meta name="description" content="Yalantis团队简直就是我的偶像，用OC和Swift代码实现了诸多炫酷的动效。在这里，我将以Yalantis的StarWars.iOS作为分析对象，剖析其中几个炫酷动效的实现，就当学习了。
StarWars.iOS（https://github.com/Yalantis/StarWars.iOS）是超炫酷的一套动效，其Swift代码的实现在Github已经获得2400+赞，效果如下：


我在这里想要剖析的主要是3块：

星空背景；
点击开关后的过渡动效；
破裂散落效果；">
  

  <!--Author-->
  
      <meta name="author" content="Fnoz">
  

  <!-- Pure CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css?family=Crimson+Text|Open+Sans:300,800" rel="stylesheet">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/styles.css">

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->

  <!-- Google Analytics -->
  

</head>


  <body>
  	<div class="container-fluid navbar-container m-sm-5">
      <!-- Header -->
      <nav class="navbar navbar-toggleable-sm navbar-light px-1 py-3 my-3 mb-sm-5">
  <a class="navbar-brand ml-2" href="/">I'm Fnoz</a>
  <button class="navbar-toggler navbar-toggler-right py-2" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse text-center" id="navbarCollapse">
    <ul class="navbar-nav ml-auto my-auto">
      
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://www.instagram.com">Instagram</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://www.linkedin.com">LinkedIn</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://www.facebook.com">Facebook</a>
        </li>
      
    </ul>
    <hr class="hidden-md-up" />
  </div>
</nav>


  		<div class="row">
  			<div class="col-12 mb-4">
  <img class="img-fluid project-img" src="/images/unsplash.jpg" alt="Swift炫酷动效StarWars.iOS剖析">
</div>
<div class="col-lg-4 col-12 pt-3 px-4 pr-lg-5">
  <h1>Swift炫酷动效StarWars.iOS剖析</h1>
</div>
<div class="col-lg-8 col-12 pt-lg-3 mb-4 pl-lg-5 px-lg-0 px-4 portfolio-content">
  <p>Yalantis团队简直就是我的偶像，用OC和Swift代码实现了诸多炫酷的动效。在这里，我将以Yalantis的StarWars.iOS作为分析对象，剖析其中几个炫酷动效的实现，就当学习了。</p>
<p>StarWars.iOS（<a href="https://github.com/Yalantis/StarWars.iOS" target="_blank" rel="noopener">https://github.com/Yalantis/StarWars.iOS</a>）是超炫酷的一套动效，其Swift代码的实现在Github已经获得2400+赞，效果如下：</p>
<div align="center"><br><img src="http://fnoz-blog.bj.bcebos.com/20160712_00.gif" alt="star_wars-concept.gif"><br></div>

<p>我在这里想要剖析的主要是3块：</p>
<ol>
<li>星空背景；</li>
<li>点击开关后的过渡动效；</li>
<li>破裂散落效果；<a id="more"></a>
</li>
</ol>
<p>建议clone一份<a href="https://github.com/Yalantis/StarWars.iOS" target="_blank" rel="noopener">代码</a>，不然估计是看得一头雾水了。</p>
<p>##1. 星空背景</p>
<div align="center"><br><img src="http://fnoz-blog.bj.bcebos.com/20160712_01.gif" alt="gif0.gif"><br></div>

<p>这个之前我用过，靠<code>CAEmitterLayer</code>和<code>CAEmitterCell</code>实现，这两个类可以实现大部分的粒子效果，包括火焰、烟雾等效果，这边是我之前写的一个很渣的例子<a href="https://github.com/Fnoz/FNFogEaseOut" target="_blank" rel="noopener">FNFogEaseOut</a>。利用<code>CAEmitterLayer</code>和<code>CAEmitterCell</code>，可以控制粒子的形状、图案、初始速度、加速度、生命时间、缩放速率等等。</p>
<p>在这里看一下核心的代码段（<code>StarsOverlay.swift</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emitter.emitterMode = kCAEmitterLayerOutline</span><br><span class="line">emitter.emitterShape = kCAEmitterLayerCircle</span><br><span class="line">emitter.renderMode = kCAEmitterLayerOldestFirst</span><br><span class="line">emitter.preservesDepth = true</span><br></pre></td></tr></table></figure>
<p>在这里指定了<code>CAEmitterLayer</code>的发送模式（<code>kCAEmitterLayerOutline</code>）、发送源形状（<code>kCAEmitterLayerOutline</code>）、渲染模式（<code>kCAEmitterLayerOldestFirst</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">particle = CAEmitterCell() </span><br><span class="line">particle.contents = UIImage(named: &quot;spark&quot;)!.CGImage</span><br><span class="line">particle.birthRate = 10</span><br><span class="line">particle.lifetime = 50</span><br><span class="line">particle.lifetimeRange = 5</span><br><span class="line">particle.velocity = 20</span><br><span class="line">particle.velocityRange = 10</span><br><span class="line">particle.scale = 0.02</span><br><span class="line">particle.scaleRange = 0.1</span><br><span class="line">particle.scaleSpeed = 0.02</span><br><span class="line">emitter.emitterCells = [particle]</span><br></pre></td></tr></table></figure>
<p>让<code>CAEmitterCell</code>以10个/s的生成速率生成，并指定了粒子的生命时间、速度、缩放比例和缩放速度。</p>
<p>最后实现的效果非常梦幻，非常关键的一段小代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emitterTimer = NSTimer.scheduledTimerWithTimeInterval(0.1, target: self, selector: #selector(randomizeEmitterPosition), userInfo: nil, repeats: true)</span><br><span class="line">func randomizeEmitterPosition() &#123;</span><br><span class="line">	let sizeWidth = max(bounds.width, bounds.height)</span><br><span class="line">	let radius = CGFloat(arc4random()) % sizeWidth</span><br><span class="line">	emitter.emitterSize = CGSize(width: radius, height: radius)</span><br><span class="line">	particle.birthRate = 10 + sqrt(Float(radius))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码使得粒子发射源的位置和生成速率具有一定的随机性，不然就会出现靠近中心的位置有很对星星，但是远一点的地方稀稀疏疏的情况。</p>
<p><em>总结：核心实现是<code>CAEmitterLayer</code>和<code>CAEmitterCell</code>。</em></p>
<p>##2. 点击开关后的过渡动效</p>
<div align="center"><br><img src="http://fnoz-blog.bj.bcebos.com/20160712_02.gif" alt="gif1.gif"><br></div>

<p>这个虽然说看着像<code>UIViewController</code>的过渡动效，实际上只是<code>UIView</code>的过渡。</p>
<p>简单的说，就是获取当前的<code>View</code>的界面新建一个<code>View</code>，再通过<code>CAShapeLayer</code>设为<code>layer.mask</code>来抠一个洞，实时调整这个洞的大小，从而实现圆形区域放大的效果。</p>
<p>核心代码（<code>UIView+CircularAnimation.swift</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let snapshot = self.snapshotViewAfterScreenUpdates(false)</span><br><span class="line">snapshot.frame = self.bounds</span><br><span class="line">self.addSubview(snapshot)</span><br></pre></td></tr></table></figure>
<p>获取当前的<code>View</code>的界面新建一个<code>View</code>，重点是<code>snapshotViewAfterScreenUpdates</code>这个方法，iOS7之后终于再也不用UIGraphics获取截图了。这个方法后面的<code>bool</code>若为<code>false</code>，取到的即是当前的页面状态；否则如果是下面这样的代码，你取到的是一片空白，因为该参数表示是否在所有效果应用在视图上了以后再获取快照：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view snapshotViewAfterScreenUpdates:YES];</span><br><span class="line">[view setAlpha:0.0];</span><br></pre></td></tr></table></figure>
<p>核心代码（<code>CircularRevealAnimator.swift</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let startCirclePath = CGPathCreateWithEllipseInRect(SquareAroundCircle(center, radius: startRadius), UnsafePointer())</span><br><span class="line">let endCirclePath = CGPathCreateWithEllipseInRect(SquareAroundCircle(center, radius: endRadius), UnsafePointer())</span><br><span class="line">var startPath = startCirclePath, endPath = endCirclePath</span><br><span class="line">var path = CGPathCreateMutable()</span><br><span class="line">CGPathAddRect(path, nil, layer.bounds)</span><br><span class="line">CGPathAddPath(path, nil, startCirclePath)</span><br><span class="line">startPath = path</span><br><span class="line">path = CGPathCreateMutable()</span><br><span class="line">CGPathAddRect(path, nil, layer.bounds)</span><br><span class="line">CGPathAddPath(path, nil, endCirclePath)</span><br><span class="line">endPath = path</span><br></pre></td></tr></table></figure>
<p><code>startPath</code>和<code>endPath</code>分别为初始状态的小圆和最终状态的大圆；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animation = CABasicAnimation(keyPath: &quot;path&quot;)</span><br><span class="line">animation.fromValue = startPath</span><br><span class="line">animation.toValue = endPath</span><br><span class="line"></span><br><span class="line">mask.addAnimation(animation, forKey: &quot;reveal&quot;)</span><br></pre></td></tr></table></figure>
<p>实现被抠区域从小变大的动效。</p>
<p><em>总结：核心实现是<code>snapshotViewAfterScreenUpdates</code>获取截图、<code>CAShapeLayer</code>指定<code>UIView</code>的<code>layer.mask</code>。</em></p>
<p>##3. 破裂散落效果</p>
<div align="center"><br><img src="http://fnoz-blog.bj.bcebos.com/20160712_03.gif" alt="gif2.gif"><br></div>

<p>其实这个效果是整套动效的关键，也是我最喜欢的部分。<br>前面讲到了<code>CAEmitterCell</code>粒子，估计会有很多人会和我一样，想用矩形或正方形的粒子来实现这个效果。不过我没能继续做下去，并且StarWars.iOS中也不是这样实现的。</p>
<p>另外，这是一个<code>UIViewController</code>的过渡动画。</p>
<p>实现的关键和上面讲到的过渡动画有一点类似：</p>
<ol>
<li>截图；</li>
<li>分割成小块；</li>
<li>散落；</li>
</ol>
<p>自定义<code>UIViewController</code>过渡动画，需要用到<code>protocol</code> <code>UIViewControllerAnimatedTransitioning</code>，实现下面2个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval</span><br><span class="line">public func animateTransition(transitionContext: UIViewControllerContextTransitioning)</span><br></pre></td></tr></table></figure>
<p>前者制定过渡动画的时长，后者可以拿到过渡前后的页面View，从而自定义过渡过程。</p>
<p>自定义过渡核心代码（<code>StarWarsUIDynamicAnimator.swift</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval &#123;</span><br><span class="line">	return self.duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>破裂散落效果核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let fromViewSnapshot = fromView.snapshotViewAfterScreenUpdates(false)</span><br><span class="line">for ... &#123;</span><br><span class="line">	for ... &#123;</span><br><span class="line">		let snapshotRegion = CGRect(x: x, y: y, width: width, height: height)</span><br><span class="line">		let snapshot = fromViewSnapshot.resizableSnapshotViewFromRect(snapshotRegion, afterScreenUpdates: false, withCapInsets: UIEdgeInsetsZero)</span><br><span class="line">		 containerView.addSubview(snapshot)</span><br></pre></td></tr></table></figure>
<p>获取当前<code>View</code>的截图<code>View</code>，并用<code>resizableSnapshotViewFromRect</code>得到各个方块所在位置的截图<code>View</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func randomFloatBetween(smallNumber: CGFloat, and bigNumber: CGFloat) -&gt; CGFloat &#123;</span><br><span class="line">	let diff = bigNumber - smallNumber</span><br><span class="line">	return CGFloat(arc4random()) / 100.0 % diff + smallNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let push = UIPushBehavior(items: [snapshot], mode: .Instantaneous)</span><br><span class="line">push.pushDirection = CGVector(dx: randomFloatBetween(-0.15 , and: 0.15), dy: randomFloatBetween(-0.15 , and: 0))</span><br><span class="line">push.active = true</span><br><span class="line">animator.addBehavior(push)</span><br><span class="line">                </span><br><span class="line">let gravity = UIGravityBehavior(items: snapshots)</span><br><span class="line">animator.addBehavior(gravity)</span><br></pre></td></tr></table></figure>
<p>给每个小块加上瞬间（<code>Instantaneous</code>）的推力（<code>UIPushBehavior</code>），<code>randomFloatBetween</code>的随机部分，使得每个小块在竖直和水平上都有些错开，达到裂开的效果。</p>
<p>给snapshots加上重力，实现下落的效果。</p>
<p>##总结</p>
<p>其实我早就想仔细研究这个动效的实现了，但是看着这么炫酷，总感觉是超复杂的实现。潜下心来看代码，虽然代码也不短，但是从实现思路和核心知识点来看，都不复杂。</p>
<p>这3个动效学到的新知识：<code>CAEmitterLayer</code>和<code>CAEmitterCell</code>、<code>snapshotViewAfterScreenUpdates</code>截图、<code>UIPushBehavior</code>和<code>UIGravityBehavior</code>。</p>

</div>


      </div>
      
  	</div>

    <!-- After footer scripts -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>

  </body>
</html>
